<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="AppBase.ORM" #>
<#@ output extension=".cs" #>
<#
var modelPath = Path.Combine(
    Host.ResolveAssemblyReference("$(ProjectDir)"),
        "CompleteModel.json"
    );
var model = Model.Load(modelPath);
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AppBase.ORM.Entities
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Data;
    using System.Data.SqlClient;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
<#
foreach (var entity in model.Entities)
{
    var lists = new List<Tuple<ModelField, string, string>>();
    var hierarchy = model.GetEntityRelationHierarchy(entity);
    var entityRelationFields =
        new Dictionary<ModelField, Tuple<string, string, ModelField>>();
    foreach (var relationField in entity.GetRelationFields())
    {
        var relationChain = model.GetRelationEntityChain(
            relationField.Relation,
            entity
            );
        if (relationChain.RelationType == ModelRelationEntityChainType.OneToOne ||
            relationChain.RelationType == ModelRelationEntityChainType.ManyToOne)
            foreach (var field in relationChain.GetRelationFields())
                if (field.Key != null && field.Value != null)
                    entityRelationFields[field.Key] = new Tuple<string, string, ModelField>(
                        relationChain.End2.Name,
                        relationField.FieldName,
                        field.Value
                        );
    }
#>

    #region <#= entity.Name #>
    public partial class <#= entity.Name #> : BaseEntity
    {
<#
    foreach (var field in entity.Fields.OrderBy(x => !string.IsNullOrEmpty(x.Relation)))
    {
        var privateFieldName = "_" + Char.ToLowerInvariant(field.FieldName[0]) + field.FieldName.Substring(1);
        var getFn = "get { return " + privateFieldName + "; }";
        var setFn = "set { " + privateFieldName + " = value; }";
        var type = string.IsNullOrEmpty(field.Relation)
            ? field.GetFieldType()
            : model.GetEntityType(field.Relation, entity);
        if (type.StartsWith("BaseEntityCollection<"))
        {
            setFn = "internal " + setFn;
            lists.Add(
                new Tuple<ModelField, string, string>(
                    field,
                    privateFieldName,
                    type
                    ));
        }
#>
        #region <#= field.FieldName #>
        private <#= type #> <#= privateFieldName #>;
        /// <summary>
        /// Get or set <#= field.FieldName #>
        /// </summary>
        public <#= type #> <#= field.FieldName #>
        {
            <#= getFn #>
            <#= setFn #>
        }
        #endregion

<#
    }
#>
        public <#= entity.Name #>()
        {
<#
        foreach (var item in lists)
        {
#>
            <#= item.Item2 #> = new <#= item.Item3 #>();
<#
            var relationChain = model.GetRelationEntityChain(
                item.Item1.Relation,
                entity
                );
            if (relationChain.RelationType != ModelRelationEntityChainType.ManyToMany)
            {
                var relationFields = relationChain.GetRelationFields();
#>
            <#= item.Item2 #>.CollectionEntityFlatten +=
                (<#= relationChain.End2.Name #> entity) =>
                {
<#
                foreach (var field in relationFields)
                {
#>
                    entity.<#= field.Value.FieldName #> = <#= field.Key.FieldName #>;
<#
                }
#>
                };
<#
            }
        }
#>
        }

        /// <summary>
        /// Create a new instance of repository
        /// </summary>
        /// <param name="conn">DB connection</param>
        /// <returns>Repository</returns>
        public override BaseRepository CreateRepository(SqlConnection conn)
        {
            return new <#= entity.Name #>Repository(conn);
        }
    }
<#
        var entityKeyFields = entity.GetKeyFields();
        var entityInsertFields = entity.GetInsertFields();
#>

    public partial class <#= entity.Name #>Repository : BaseRepository
    {
        public <#= entity.Name #>Repository(SqlConnection conn)
            : base(conn, new List<Type>() { <#= string.Join(", ", hierarchy.Select(x => "typeof(" + x.Name + ")")) #> })
        {
        }

        /// <summary>
        /// Insert or update entity
        /// </summary>
        /// <param name="entity">Entity</param>
        /// <param name="tr">Transaction</param>
        /// <param name="skipNestedObjects">
        ///     Flag specifying whether to skip or not InsertOrUpdate for nested objects (optional)
        /// </param>
        public override void InsertOrUpdate(BaseEntity entity, SqlTransaction tr, bool skipNestedObjects = false)
        {
            if (entity == null)
                throw new ArgumentNullException("entity");
            if (!(entity is <#= entity.Name #>))
                throw new ModelException(
                    "<#= entity.Name #>Repository " +
                    "cannot perform operations on \"" + entity.GetType().Name + "\""
                    );

            var typedEntity = (<#= entity.Name #>)entity;

<#
        var fieldsToValidate =
            entityInsertFields
                .Where(x => x.IsNullable != true && !Type.GetType(x.GetFieldType()).IsValueType)
                .ToList();
        foreach (var relationField in entityRelationFields)
            fieldsToValidate
                .Remove(relationField.Key);
        if (fieldsToValidate.Count > 0)
        {
#>
            #region Validate fields
<#
            foreach (var field in fieldsToValidate)
            {
#>
            if (typedEntity.<#= field.FieldName #> == null)
                throw new ArgumentNullException("entity.<#= field.FieldName #>");
<#
            }
#>
            #endregion

<#
        }
#>
            Delete(entity, tr, skipNestedObjects);

            using (var cmd = Connection.CreateCommand())
            {
                cmd.Transaction = tr;

                if (!skipNestedObjects)
                {
                    foreach (var nestedEntity in typedEntity.Flatten().OrderBy(x => Hierarchy.IndexOf(x.GetType())))
                        nestedEntity.CreateRepository(Connection).InsertOrUpdate(nestedEntity, tr, true);
                }
                else
                {
                    #region Insert <#= entity.Name #>
                    cmd.CommandText = @"
                        INSERT INTO [dbo].[<#= entity.TableName #>] (<#= string.Join(", ", entityInsertFields.Select(x => "[" + x.FieldName + "]")) #>) VALUES
                            (<#= string.Join(", ", entityInsertFields.Select(x => "@" + x.FieldName)) #>);
                        ";
<#
        foreach (var field in entityInsertFields)
        {
            var path = "typedEntity." + field.FieldName;
                if (entityRelationFields.ContainsKey(field))
                    path = "typedEntity?." + entityRelationFields[field].Item2 + "?." + entityRelationFields[field].Item3.FieldName + " ?? "  + path;

            if (field.IsNullable == true)
            {
#>
                    cmd.Parameters.AddWithValue("@<#= field.FieldName #>", <#= path #> ?? (object)DBNull.Value);
<#
            }
            else
            {
#>
                    cmd.Parameters.AddWithValue("@<#= field.FieldName #>", <#= path #>);
<#
            }
        }
#>
                    Debug.WriteLine("<#= entity.Name #>Repository.InsertOrUpdate: INSERT INTO [dbo].[<#= entity.TableName #>]; " +
                        "SkipNestedObjects=" + skipNestedObjects);
                    Debug.WriteLine("    " + <#= string.Join(" + \";\" + ", entityKeyFields.Select(x => "\"" + x.FieldName + "=\" + typedEntity." + x.FieldName)) #>);
                    cmd.ExecuteNonQuery();
                    #endregion
                }

<#
        foreach (var relationField in entity.GetRelationFields())
        {
            var relationChain = model.GetRelationEntityChain(
                relationField.Relation,
                entity
                );
            switch (relationChain.RelationType)
            {
                case ModelRelationEntityChainType.ManyToMany:
                    var relation = relationChain.Parent.Relations.FirstOrDefault(
                        x => x.EntityName.Equals(entity.Name, StringComparison.InvariantCultureIgnoreCase));
                    var relationFields = new Dictionary<string, ModelField>();
                    foreach (var field in relation.Fields)
                        relationFields.Add(field.ParentColumnName,
                            entity.Fields.FirstOrDefault(
                                x => x.ColumnName != null &&
                                x.ColumnName.Equals(field.ChildColumnName, StringComparison.InvariantCultureIgnoreCase))
                                );
                    foreach (var field in relationChain.Relation.Fields)
                        relationFields.Add(field.ParentColumnName,
                            relationChain.End2.Fields.FirstOrDefault(
                                x => x.ColumnName != null &&
                                x.ColumnName.Equals(field.ChildColumnName, StringComparison.InvariantCultureIgnoreCase))
                                );
#>
                #region Insert <#= relationChain.Parent.Name #>
                foreach (var item in typedEntity.<#= relationField.FieldName #>)
                {
                    cmd.Parameters.Clear();
                    cmd.CommandText = @"
                        INSERT INTO [dbo].[<#= relationChain.Parent.TableName #>] (<#= string.Join(", ", relationFields.Select(x => "[" + x.Key + "]")) #>) VALUES
                            (<#= string.Join(", ", relationFields.Select(x => "@" + x.Key)) #>);
                        ";
<#
                    foreach (var field in relationFields)
                    {
                        var path = "typedEntity";
                        if (relationChain.End2.Fields.Contains(field.Value))
                            path = "item";
#>
                    cmd.Parameters.AddWithValue("@<#= field.Key #>", <#= path #>.<#= field.Value.FieldName #>);
<#
                    }
#>
                    Debug.WriteLine("<#= entity.Name #>Repository.InsertOrUpdate: INSERT INTO [dbo].[<#= relationChain.Parent.TableName #>]; " +
                        "SkipNestedObjects=" + skipNestedObjects);
                    Debug.WriteLine("    " + <#= string.Join(" + \";\" + ", entityKeyFields.Select(x => "\"" + x.FieldName + "=\" + typedEntity." + x.FieldName)) #>);
                    cmd.ExecuteNonQuery();
                }
                #endregion

<#
                    break;
            }
        }
#>
            }
        }

        /// <summary>
        /// Delete entity
        /// </summary>
        /// <param name="entity">Entity</param>
        /// <param name="tr">Transaction</param>
        /// <param name="skipNestedObjects">
        ///     Flag specifying whether to skip or not Delete for nested objects (optional)
        /// </param>
        public override void Delete(BaseEntity entity, SqlTransaction tr, bool skipNestedObjects = false)
        {
            if (entity == null)
                throw new ArgumentNullException("entity");
            if (!(entity is <#= entity.Name #>))
                throw new ModelException(
                    "<#= entity.Name #>Repository " +
                    "cannot perform operations on \"" + entity.GetType().Name + "\""
                    );

            var typedEntity = (<#= entity.Name #>)entity;

            using (var cmd = Connection.CreateCommand())
            {
                cmd.Transaction = tr;

<#
        var nestedObjectsToSkip = new List<ModelField>();

        foreach (var relationField in entity.GetRelationFields())
        {
            var relationChain = model.GetRelationEntityChain(
                relationField.Relation,
                entity
                );
            switch (relationChain.RelationType)
            {
                case ModelRelationEntityChainType.ManyToMany:
                case ModelRelationEntityChainType.OneToMany:
                    var relation = relationChain.Parent.Relations.FirstOrDefault(
                        x => x.EntityName.Equals(entity.Name, StringComparison.InvariantCultureIgnoreCase));
                    var relationFields = new Dictionary<string, ModelField>();
                    foreach (var field in relation.Fields)
                        relationFields.Add(field.ParentColumnName,
                            entity.Fields.FirstOrDefault(
                                x => x.ColumnName != null &&
                                x.ColumnName.Equals(field.ChildColumnName, StringComparison.InvariantCultureIgnoreCase))
                                );
                    if (relationChain.RelationType == ModelRelationEntityChainType.ManyToMany)
                        nestedObjectsToSkip.Add(relationField);
                    if (relationChain.RelationType == ModelRelationEntityChainType.OneToMany)
                        if (relationFields.All(x => x.Value.IsNullable == true) &&
                            relationField.CascadeDelete != true)
                        {
                            nestedObjectsToSkip.Add(relationField);
                            continue;
                        }
#>
                #region Delete <#= relationChain.Parent.Name #>
                cmd.Parameters.Clear();
                cmd.CommandText = @"
                    DELETE FROM [dbo].[<#= relationChain.Parent.TableName #>] WHERE
                        (<#= string.Join("AND ", relationFields.Select(x => "[" + x.Key + "] = @" + x.Value.FieldName)) #>);
                    ";
<#
                    foreach (var field in relationFields)
                    {
#>
                cmd.Parameters.AddWithValue("@<#= field.Key #>", typedEntity.<#= field.Value.FieldName #>);
<#
                    }
#>
                Debug.WriteLine("<#= entity.Name #>Repository.Delete: DELETE FROM [dbo].[<#= relationChain.Parent.TableName #>]; " +
                    "SkipNestedObjects=" + skipNestedObjects);
                Debug.WriteLine("    " + <#= string.Join(" + \";\" + ", entityKeyFields.Select(x => "\"" + x.FieldName + "=\" + typedEntity." + x.FieldName)) #>);
                cmd.ExecuteNonQuery();
                #endregion

<#
                    break;
                case ModelRelationEntityChainType.ManyToOne:
                    nestedObjectsToSkip.Add(relationField);
                    break;
            }
        }
#>
                if (!skipNestedObjects)
                {
<#
        if (nestedObjectsToSkip.Count > 0)
        {
            foreach (var field in nestedObjectsToSkip)
            {
#>
                    var temp<#= field.FieldName #> = typedEntity.<#= field.FieldName #>;
                    typedEntity.<#= field.FieldName #> = null;
<#
            }
#>

<#
        }
#>
                    foreach (var nestedEntity in typedEntity.Flatten().OrderBy(x => Hierarchy.IndexOf(x.GetType())))
                        nestedEntity.CreateRepository(Connection).Delete(nestedEntity, tr, true);

<#
        if (nestedObjectsToSkip.Count > 0)
        {
            foreach (var field in nestedObjectsToSkip)
            {
#>
                    typedEntity.<#= field.FieldName #> = temp<#= field.FieldName #>;
<#
            }
#>

<#
        }
#>
                }
                else
                {
                    #region Delete <#= entity.Name #>
                    cmd.Parameters.Clear();
                    cmd.CommandText = @"
                        DELETE FROM [dbo].[<#= entity.TableName #>] WHERE
                            (<#= string.Join(" AND ", entityKeyFields.Select(x => "[" + x.ColumnName + "] = @" + x.FieldName)) #>);
                        ";
<#
        foreach (var field in entityKeyFields)
        {
            var path = "typedEntity." + field.FieldName;
                if (entityRelationFields.ContainsKey(field))
                    path = "typedEntity?." + entityRelationFields[field].Item2 + "?." + entityRelationFields[field].Item3.FieldName + " ?? "  + path;
#>
                    cmd.Parameters.AddWithValue("@<#= field.FieldName #>", <#= path #>);
<#
        }
#>
                    Debug.WriteLine("<#= entity.Name #>Repository.Delete: DELETE FROM [dbo].[<#= entity.TableName #>]; " +
                        "SkipNestedObjects=" + skipNestedObjects);
                    Debug.WriteLine("    " + <#= string.Join(" + \"; \" + ", entityKeyFields.Select(x => "\"" + x.FieldName + "=\" + typedEntity." + x.FieldName)) #>);
                    cmd.ExecuteNonQuery();
                    #endregion
                }
            }
        }
    }
    #endregion
<#
}
#>
}
