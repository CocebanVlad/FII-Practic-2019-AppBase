<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="AppBase.ORM" #>
<#@ output extension=".cs" #>
<#
var modelPath = Path.Combine(
    Host.ResolveAssemblyReference("$(ProjectDir)"),
        "CompleteModel.json"
    );
var model = Model.Load(modelPath);
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AppBase.ORM.Entities
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
<#
foreach (var entity in model.Entities)
{
    var lists = new Dictionary<string, string>();
#>

    #region <#= entity.Name #>
    public partial class <#= entity.Name #> : BaseEntity
    {
<#
    foreach (var field in entity.Fields.OrderBy(x => !string.IsNullOrEmpty(x.Relation)))
    {
        var accessFns = "get; set;";
        var type = string.IsNullOrEmpty(field.Relation) 
            ? field.GetFieldType()
            : model.GetEntityType(field.Relation, entity);
        if (type.StartsWith("BaseEntityCollection<"))
        {
            accessFns = "get; internal set;";
            lists.Add(
                field.FieldName,
                type
                );
        }
#>
        /// <summary>
        /// Get or set <#= field.FieldName #>
        /// </summary>
        public <#= type #> <#= field.FieldName #> { <#= accessFns #> }

<#
    }
#>
        public <#= entity.Name #>()
        {
<#
        foreach (var item in lists)
        {
#>
            <#= item.Key #> = new <#= item.Value #>();
<#
        }
#>
        }

        /// <summary>
        /// Create a new instance of repository
        /// </summary>
        /// <param name="conn">DB connection</param>
        /// <returns>Repository</returns>
        public override BaseRepository CreateRepository(SqlConnection conn)
        {
            return new <#= entity.Name #>Repository(conn);
        }
    }
<#
        var entityKeyFields = entity.GetKeyFields();
        var entityInsertFields = entity.GetInsertFields();
#>

    public partial class <#= entity.Name #>Repository : BaseRepository
    {
        public <#= entity.Name #>Repository(SqlConnection conn)
            : base(conn)
        {
        }

        /// <summary>
        /// Insert or update entity
        /// </summary>
        /// <param name="entity">Entity</param>
        /// <param name="tr">Transaction</param>
        /// <param name="skipNestedObjects">
        ///     Flag specifying whether to skip or not InsertOrUpdate for nested objects (optional)
        /// </param>
        public override void InsertOrUpdate(BaseEntity entity, SqlTransaction tr, bool skipNestedObjects = false)
        {
            if (entity == null)
                throw new ArgumentNullException("entity");
            if (!(entity is <#= entity.Name #>))
                throw new ModelException(
                    "<#= entity.Name #>Repository " +
                    "cannot perform operations on \"" + entity.GetType().Name + "\""
                    );
            
            var typedEntity = (<#= entity.Name #>)entity;

<#
        var fieldsToValidate =
            entityInsertFields
                .Where(x => x.IsNullable != true)
                .ToList();
        if (fieldsToValidate.Count > 0)
        {
#>
            #region Validate fields
<#
            foreach (var field in fieldsToValidate)
            {
#>
            if (typedEntity.<#= field.FieldName #> == null)
                throw new ArgumentNullException("entity.<#= field.FieldName #>");
<#
            }
#>
            #endregion

<#
        }
#>
            Delete(entity, tr, skipNestedObjects);

            using (var cmd = Connection.CreateCommand())
            {
                cmd.Transaction = tr;

                if (!skipNestedObjects)
                    foreach (var nestedEntity in typedEntity.Flatten().Reverse())
                        if (nestedEntity != typedEntity)
                            nestedEntity.CreateRepository(Connection).InsertOrUpdate(nestedEntity, tr, true);

                #region Insert <#= entity.Name #>
                cmd.CommandText = @"
                    INSERT INTO [dbo].[<#= entity.TableName #>] (<#= string.Join(", ", entityInsertFields.Select(x => "[" + x.FieldName + "]")) #>) VALUES
                        (<#= string.Join(", ", entityInsertFields.Select(x => "@" + x.FieldName)) #>);
                    ";
<#
        foreach (var field in entityInsertFields)
        {
            if (field.IsNullable == true)
            {
#>
                cmd.Parameters.AddWithValue("@<#= field.FieldName #>", typedEntity.<#= field.FieldName #> ?? (object)DBNull.Value);
<#
            }
            else
            {
#>
                cmd.Parameters.AddWithValue("@<#= field.FieldName #>", typedEntity.<#= field.FieldName #>);
<#
            }
        }
#>
                cmd.ExecuteNonQuery();
                #endregion

<#
        foreach (var relationField in entity.Fields.Where(x => !string.IsNullOrEmpty(x.Relation)))
        {
            var relationChain = model.GetRelationEntityChain(
                relationField.Relation,
                entity
                );
            switch (relationChain.RelationType)
            {
                case ModelRelationEntityChainType.ManyToMany:
                    var relation = relationChain.Parent.Relations.FirstOrDefault(
                        x => x.EntityName.Equals(entity.Name, StringComparison.InvariantCultureIgnoreCase));
                    var relationFields = new Dictionary<string, ModelField>();
                    foreach (var field in relation.Fields)
                        relationFields.Add(field.ParentColumnName,
                            entity.Fields.FirstOrDefault(
                                x => x.ColumnName != null &&
                                x.ColumnName.Equals(field.ChildColumnName, StringComparison.InvariantCultureIgnoreCase))
                                );
                    foreach (var field in relationChain.Relation.Fields)
                        relationFields.Add(field.ParentColumnName,
                            relationChain.End2.Fields.FirstOrDefault(
                                x => x.ColumnName != null &&
                                x.ColumnName.Equals(field.ChildColumnName, StringComparison.InvariantCultureIgnoreCase))
                                );
#>
                #region Insert <#= relationChain.Parent.Name #>
                foreach (var item in typedEntity.<#= relationField.FieldName #>)
                {
                    cmd.Parameters.Clear();
                    cmd.CommandText = @"
                        INSERT INTO [dbo].[<#= relationChain.Parent.TableName #>] (<#= string.Join(", ", relationFields.Select(x => "[" + x.Key + "]")) #>) VALUES
                            (<#= string.Join(", ", relationFields.Select(x => "@" + x.Key)) #>);
                        ";
<#
                    foreach (var field in relationFields)
                    {
                        var path = "typedEntity";
                        if (relationChain.End2.Fields.Contains(field.Value))
                            path = "item";
#>
                    cmd.Parameters.AddWithValue("@<#= field.Key #>", <#= path #>.<#= field.Value.FieldName #>);
<#
                    }
#>
                    cmd.ExecuteNonQuery();
                }
                #endregion

<#
                    break;
            }
        }
#>
            }
        }

        /// <summary>
        /// Delete entity
        /// </summary>
        /// <param name="entity">Entity</param>
        /// <param name="tr">Transaction</param>
        /// <param name="skipNestedObjects">
        ///     Flag specifying whether to skip or not Delete for nested objects (optional)
        /// </param>
        public override void Delete(BaseEntity entity, SqlTransaction tr, bool skipNestedObjects = false)
        {
            if (entity == null)
                throw new ArgumentNullException("entity");
            if (!(entity is <#= entity.Name #>))
                throw new ModelException(
                    "<#= entity.Name #>Repository " +
                    "cannot perform operations on \"" + entity.GetType().Name + "\""
                    );
            
            var typedEntity = (<#= entity.Name #>)entity;

            using (var cmd = Connection.CreateCommand())
            {
                cmd.Transaction = tr;

<#
        var nestedObjectsToSkip = new List<ModelField>();

        foreach (var relationField in entity.Fields.Where(x => !string.IsNullOrEmpty(x.Relation)))
        {
            var relationChain = model.GetRelationEntityChain(
                relationField.Relation,
                entity
                );
            switch (relationChain.RelationType)
            {
                case ModelRelationEntityChainType.ManyToMany:
                case ModelRelationEntityChainType.OneToMany:
                    var relation = relationChain.Parent.Relations.FirstOrDefault(
                        x => x.EntityName.Equals(entity.Name, StringComparison.InvariantCultureIgnoreCase));
                    var relationFields = new Dictionary<string, ModelField>();
                    foreach (var field in relation.Fields)
                        relationFields.Add(field.ParentColumnName,
                            entity.Fields.FirstOrDefault(
                                x => x.ColumnName != null &&
                                x.ColumnName.Equals(field.ChildColumnName, StringComparison.InvariantCultureIgnoreCase))
                                );
                    if (relationChain.RelationType == ModelRelationEntityChainType.ManyToMany)
                        nestedObjectsToSkip.Add(relationField);
                    if (relationChain.RelationType == ModelRelationEntityChainType.OneToMany)
                        if (relationFields.All(x => x.Value.IsNullable == true) && 
                            relationField.CascadeDelete != true)
                        {
                            nestedObjectsToSkip.Add(relationField);
                            continue;
                        }
#>
                #region Delete <#= relationChain.Parent.Name #>
                cmd.Parameters.Clear();
                cmd.CommandText = @"
                    DELETE FROM [dbo].[<#= relationChain.Parent.TableName #>] WHERE
                        (<#= string.Join("AND ", relationFields.Select(x => "[" + x.Key + "] = @" + x.Value.FieldName)) #>);
                    ";
<#
                    foreach (var field in relationFields)
                    {
#>
                cmd.Parameters.AddWithValue("@<#= field.Key #>", typedEntity.<#= field.Value.FieldName #>);
<#
                    }
#>
                cmd.ExecuteNonQuery();
                #endregion

<#
                    break;
                case ModelRelationEntityChainType.ManyToOne:
                    nestedObjectsToSkip.Add(relationField);
                    break;
            }
        }

        if (nestedObjectsToSkip.Count > 0)
        {
            foreach (var field in nestedObjectsToSkip)
            {
#>
                var temp<#= field.FieldName #> = typedEntity.<#= field.FieldName #>;
                typedEntity.<#= field.FieldName #> = null;
<#
            }
#>

<#
        }
#>
                if (!skipNestedObjects)
                    foreach (var nestedEntity in typedEntity.Flatten().Reverse())
                        if (nestedEntity != typedEntity)
                            nestedEntity.CreateRepository(Connection).Delete(nestedEntity, tr, true);

<#
        if (nestedObjectsToSkip.Count > 0)
        {
            foreach (var field in nestedObjectsToSkip)
            {
#>
                typedEntity.<#= field.FieldName #> = temp<#= field.FieldName #>;
<#
            }
#>

<#
        }
#>
                #region Delete <#= entity.Name #>
                cmd.Parameters.Clear();
                cmd.CommandText = @"
                    DELETE FROM [dbo].[<#= entity.TableName #>] WHERE
                        (<#= string.Join(" AND ", entityKeyFields.Select(x => "[" + x.ColumnName + "] = @" + x.FieldName)) #>);
                    ";
<#
        foreach (var field in entityKeyFields)
        {
#>
                cmd.Parameters.AddWithValue("@<#= field.FieldName #>", typedEntity.<#= field.FieldName #>);
<#
        }
#>
                cmd.ExecuteNonQuery();
                #endregion
            }
        }
    }
    #endregion
<#
}
#>
}
